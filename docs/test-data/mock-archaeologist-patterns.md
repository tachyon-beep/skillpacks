# Subsystem Catalog - E-commerce Platform

**Generated by:** axiom-system-archaeologist
**Date:** 2025-11-13
**Codebase:** /legacy-ecommerce-platform

---

## Database Access Patterns

### Pattern 1: Raw SQL Queries
**Locations:** OrderService (src/services/orders/), ReportingService (src/reporting/)
**Implementation:** Direct SQL string construction and execution
**Example:** `orders.py:45` - `cursor.execute(f"SELECT * FROM orders WHERE user_id = {user_id}")`

### Pattern 2: ORM (SQLAlchemy)
**Locations:** UserService (src/services/users/), ProductCatalog (src/catalog/)
**Implementation:** SQLAlchemy models with query API
**Example:** `user_repository.py:23` - `session.query(User).filter(User.id == user_id).first()`

### Pattern 3: Query Builder
**Locations:** AnalyticsService (src/analytics/)
**Implementation:** Custom query builder class
**Example:** `analytics.py:67` - `QueryBuilder().table('events').where('user_id', user_id).get()`

### Pattern 4: Stored Procedures
**Locations:** PaymentService (src/payments/), InventoryService (src/inventory/)
**Implementation:** Calls to PostgreSQL stored procedures
**Example:** `payment_processor.py:89` - `cursor.callproc('process_payment', [order_id, amount])`

### Pattern 5: Direct Database Access
**Locations:** AdminPanel (src/admin/), DataExport (src/export/)
**Implementation:** psycopg2 connection pooling with direct queries
**Example:** `admin_queries.py:12` - Direct connection, no abstraction

### Pattern 6: CSV Export/Import
**Locations:** IntegrationService (src/integrations/), LegacySync (src/legacy/)
**Implementation:** Database → CSV → Filesystem → CSV → Database
**Example:** `legacy_sync.py:34` - Exports to CSV, partner reads file, imports from their CSV

---

## Authentication Patterns

### Pattern 1: JWT Tokens
**Locations:** APIGateway (src/api/), MobileBackend (src/mobile/)
**Implementation:** JWT tokens in Authorization header
**Token lifetime:** 24 hours
**Storage:** Redis cache for validation

### Pattern 2: Session Cookies
**Locations:** WebApp (src/web/), CustomerPortal (src/portal/)
**Implementation:** Flask session management with server-side sessions
**Storage:** Database session table

### Pattern 3: API Keys
**Locations:** AdminPanel (src/admin/), InternalTools (src/tools/)
**Implementation:** Static API keys in config files
**Validation:** Direct string comparison against config

---

## Service Communication Patterns

### Pattern 1: REST API Calls
**Locations:** 8 service pairs
**Examples:**
- OrderService → InventoryService (check stock)
- OrderService → PaymentService (process payment)
- UserService → NotificationService (send email)
- ProductCatalog → PricingService (get prices)

### Pattern 2: Direct Database Access
**Locations:** 12 service pairs
**Examples:**
- ReportingService → Orders table (read-only analytics)
- AdminPanel → All tables (full access)
- InventoryService → Orders table (check order status)
- ProductCatalog → Users table (check user preferences)

### Pattern 3: Shared Filesystem
**Locations:** 4 service pairs
**Examples:**
- OrderService → FulfillmentService (write order.json, fulfillment reads)
- ReportingService → DataExport (CSV files in /shared/exports/)
- IntegrationService → LegacySync (XML files in /shared/integration/)

### Pattern 4: Message Queue
**Locations:** 2 service pairs
**Examples:**
- OrderService → EmailService (RabbitMQ: order.placed event)
- PaymentService → OrderService (RabbitMQ: payment.completed event)

---

## Error Handling Patterns

### Pattern 1: Try/Catch with Logging
**Locations:** UserService, ProductCatalog, APIGateway, OrderService
**Implementation:**
```python
try:
    result = do_operation()
    return result
except Exception as e:
    logger.error(f"Operation failed: {e}")
    raise
```

### Pattern 2: Error Codes
**Locations:** PaymentService, InventoryService, LegacySync
**Implementation:**
```python
def process_payment(order_id):
    if not valid_order(order_id):
        return {"status": "ERROR", "code": "INVALID_ORDER"}
    # ...
    return {"status": "SUCCESS", "code": "PAYMENT_PROCESSED"}
```

### Pattern 3: Uncaught Exceptions
**Locations:** ReportingService, AnalyticsService, DataExport, AdminPanel, InternalTools
**Implementation:** No error handling, exceptions propagate to framework
```python
def generate_report(params):
    data = fetch_data(params)  # May raise, not caught
    return process(data)        # May raise, not caught
```

### Pattern 4: Silent Failures
**Locations:** IntegrationService, FulfillmentService
**Implementation:**
```python
try:
    sync_with_partner()
except Exception:
    pass  # Silent failure, no logging
```

---

## Archaeologist Notes

**Pattern Diversity:** Observed 6 database access patterns, 3 authentication patterns, 4 communication patterns, and 4 error handling patterns across the codebase.

**No Consistency Enforcement:** No apparent architectural guidelines or pattern enforcement mechanisms detected.

**Historical Context:** Git history shows patterns accumulated over 5 years (2019-2024) as different developers joined/left team.

**Documentation Gap:** No ADRs (Architecture Decision Records) found explaining pattern choices.
